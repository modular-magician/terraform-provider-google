// ----------------------------------------------------------------------------
//
//     ***     AUTO GENERATED CODE    ***    Type: MMv1     ***
//
// ----------------------------------------------------------------------------
//
//     This file is automatically generated by Magic Modules and manual
//     changes will be clobbered when the file is regenerated.
//
//     Please read more about how to change this file in
//     .github/CONTRIBUTING.md.
//
// ----------------------------------------------------------------------------

package google

import (
	"context"
	"fmt"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func jobRevisionNameCustomizeDiff(_ context.Context, diff *schema.ResourceDiff, v interface{}) error {
	autogen := diff.Get("autogenerate_revision_name").(bool)
	if autogen && diff.HasChange("template.0.metadata.0.name") {
		return fmt.Errorf("google_cloud_run_job: `template.metadata.name` cannot be set while `autogenerate_revision_name` is true. Please remove the field or set `autogenerate_revision_name` to false.")
	}

	return nil
}

var cloudRunJobGoogleProvidedAnnotations = regexp.MustCompile(`serving\.knative\.dev/(?:(?:creator)|(?:lastModifier))$|run\.googleapis\.com/(?:(?:ingress-status))$|cloud\.googleapis\.com/(?:(?:location))`)

func cloudrunJobAnnotationDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the annotations provided by Google
	if cloudRunJobGoogleProvidedAnnotations.MatchString(k) && new == "" {
		return true
	}

	// Let diff be determined by annotations (above)
	if strings.Contains(k, "annotations.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var cloudRunJobGoogleProvidedTemplateAnnotations = regexp.MustCompile(`template\.0\.metadata\.0\.annotations\.run\.googleapis\.com/sandbox`)
var cloudRunJobGoogleProvidedTemplateAnnotations_autoscaling_maxscale = regexp.MustCompile(`template\.0\.metadata\.0\.annotations\.autoscaling\.knative\.dev/maxScale`)

func cloudrunJobTemplateAnnotationDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the annotations provided by API
	if cloudRunJobGoogleProvidedTemplateAnnotations.MatchString(k) &&
		old == "gvisor" && new == "" {
		return true
	}

	if cloudRunJobGoogleProvidedTemplateAnnotations_autoscaling_maxscale.MatchString(k) && new == "" {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

var cloudRunJobGoogleProvidedLabels = regexp.MustCompile(`cloud\.googleapis\.com/(?:(?:location))`)

func cloudrunJobLabelDiffSuppress(k, old, new string, d *schema.ResourceData) bool {
	// Suppress diffs for the labels provided by Google
	if cloudRunJobGoogleProvidedLabels.MatchString(k) && new == "" {
		return true
	}

	// Let diff be determined by labels (above)
	if strings.Contains(k, "labels.%") {
		return true
	}

	// For other keys, don't suppress diff.
	return false
}

func resourceCloudRunJob() *schema.Resource {
	return &schema.Resource{
		Create: resourceCloudRunJobCreate,
		Read:   resourceCloudRunJobRead,
		Update: resourceCloudRunJobUpdate,
		Delete: resourceCloudRunJobDelete,

		Importer: &schema.ResourceImporter{
			State: resourceCloudRunJobImport,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(20 * time.Minute),
			Update: schema.DefaultTimeout(20 * time.Minute),
			Delete: schema.DefaultTimeout(20 * time.Minute),
		},

		SchemaVersion: 1,
		CustomizeDiff: revisionNameCustomizeDiff,

		Schema: map[string]*schema.Schema{
			"location": {
				Type:        schema.TypeString,
				Required:    true,
				ForceNew:    true,
				Description: `The location of the cloud run instance. eg us-central1`,
			},
			"name": {
				Type:     schema.TypeString,
				Required: true,
				ForceNew: true,
				Description: `Name must be unique within a namespace, within a Cloud Run region.
Is required when creating resources. Name is primarily intended
for creation idempotence and configuration definition. Cannot be updated.
More info: http://kubernetes.io/docs/user-guide/identifiers#names`,
			},
			"status": {
				Type:        schema.TypeList,
				Computed:    true,
				Description: `The current status of the Service.`,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"conditions": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `Array of observed Service Conditions, indicating the current ready state of the service.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"message": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Human readable message indicating details about the current status.`,
									},
									"reason": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `One-word CamelCase reason for the condition's current status.`,
									},
									"status": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Status of the condition, one of True, False, Unknown.`,
									},
									"type": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Type of domain mapping condition.`,
									},
								},
							},
						},
						"execution_count": {
							Type:        schema.TypeInt,
							Computed:    true,
							Description: `Number of executions created for this job.`,
						},
						"latest_created_execution": {
							Type:        schema.TypeList,
							Computed:    true,
							Description: `A pointer to the most recently created execution for this job. This is set regardless of the eventual state of the execution.`,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"completion_timestamp": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Completion timestamp of the execution.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. 
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
									},
									"creation_timestamp": {
										Type:     schema.TypeString,
										Computed: true,
										Description: `Creation timestamp of the execution.

A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".`,
									},
									"name": {
										Type:        schema.TypeString,
										Computed:    true,
										Description: `Name of the execution.`,
									},
								},
							},
						},
						"observed_generation": {
							Type:     schema.TypeInt,
							Computed: true,
							Description: `ObservedGeneration is the 'Generation' of the Route that was last processed by the
controller.

Clients polling for completed reconciliation should poll until observedGeneration =
metadata.generation and the Ready condition's status is True or False.`,
						},
						"url": {
							Type:     schema.TypeString,
							Computed: true,
							Description: `From RouteStatus. URL holds the url that will distribute traffic over the provided traffic
targets. It generally has the form
https://{route-hash}-{project-hash}-{cluster-level-suffix}.a.run.app`,
						},
					},
				},
			},
			"autogenerate_revision_name": {
				Type:     schema.TypeBool,
				Optional: true,
				Default:  false,
				Description: `If set to 'true', the revision name (template.metadata.name) will be omitted and
autogenerated by Cloud Run. This cannot be set to 'true' while 'template.metadata.name'
is also set.
(For legacy support, if 'template.metadata.name' is unset in state while
this field is set to false, the revision name will still autogenerate.)`,
			},
			"project": {
				Type:     schema.TypeString,
				Optional: true,
				Computed: true,
				ForceNew: true,
			},
		},
		UseJSONNumber: true,
	}
}

func resourceCloudRunJobCreate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	obj := make(map[string]interface{})

	obj, err = resourceCloudRunJobEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Creating new Job: %#v", obj)
	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "POST", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutCreate), isCloudRunCreationConflict)
	if err != nil {
		return fmt.Errorf("Error creating Job: %s", err)
	}

	// Store the ID now
	id, err := replaceVars(d, config, "locations/{{location}}/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	err = PollingWaitTime(resourceCloudRunJobPollRead(d, meta), PollCheckKnativeStatusFunc(res), "Creating Job", d.Timeout(schema.TimeoutCreate), 1)
	if err != nil {
		return fmt.Errorf("Error waiting to create Job: %s", err)
	}

	log.Printf("[DEBUG] Finished creating Job %q: %#v", d.Id(), res)

	return resourceCloudRunJobRead(d, meta)
}

func resourceCloudRunJobPollRead(d *schema.ResourceData, meta interface{}) PollReadFunc {
	return func() (map[string]interface{}, error) {
		config := meta.(*Config)

		url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
		if err != nil {
			return nil, err
		}

		billingProject := ""

		project, err := getProject(d, config)
		if err != nil {
			return nil, fmt.Errorf("Error fetching project for Job: %s", err)
		}
		billingProject = project

		// err == nil indicates that the billing_project value was found
		if bp, err := getBillingProject(d, config); err == nil {
			billingProject = bp
		}

		userAgent, err := generateUserAgentString(d, config.userAgent)
		if err != nil {
			return nil, err
		}

		res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil, isCloudRunCreationConflict)
		if err != nil {
			return res, err
		}
		res, err = resourceCloudRunJobDecoder(d, meta, res)
		if err != nil {
			return nil, err
		}
		if res == nil {
			return nil, fake404("decoded", "CloudRunJob")
		}

		return res, nil
	}
}

func resourceCloudRunJobRead(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequest(config, "GET", billingProject, url, userAgent, nil, isCloudRunCreationConflict)
	if err != nil {
		return handleNotFoundError(err, d, fmt.Sprintf("CloudRunJob %q", d.Id()))
	}

	res, err = resourceCloudRunJobDecoder(d, meta, res)
	if err != nil {
		return err
	}

	if res == nil {
		// Decoding the object has resulted in it being gone. It may be marked deleted
		log.Printf("[DEBUG] Removing CloudRunJob because it no longer exists.")
		d.SetId("")
		return nil
	}

	// Explicitly set virtual fields to default values if unset
	if _, ok := d.GetOkExists("autogenerate_revision_name"); !ok {
		if err := d.Set("autogenerate_revision_name", false); err != nil {
			return fmt.Errorf("Error setting autogenerate_revision_name: %s", err)
		}
	}
	if err := d.Set("project", project); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}

	if err := d.Set("status", flattenCloudRunJobStatus(res["status"], d, config)); err != nil {
		return fmt.Errorf("Error reading Job: %s", err)
	}

	return nil
}

func resourceCloudRunJobUpdate(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	obj := make(map[string]interface{})

	obj, err = resourceCloudRunJobEncoder(d, meta, obj)
	if err != nil {
		return err
	}

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return err
	}

	log.Printf("[DEBUG] Updating Job %q: %#v", d.Id(), obj)

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "PUT", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutUpdate), isCloudRunCreationConflict)

	if err != nil {
		return fmt.Errorf("Error updating Job %q: %s", d.Id(), err)
	} else {
		log.Printf("[DEBUG] Finished updating Job %q: %#v", d.Id(), res)
	}

	err = PollingWaitTime(resourceCloudRunJobPollRead(d, meta), PollCheckKnativeStatusFunc(res), "Updating Job", d.Timeout(schema.TimeoutUpdate), 1)
	if err != nil {
		return err
	}

	return resourceCloudRunJobRead(d, meta)
}

func resourceCloudRunJobDelete(d *schema.ResourceData, meta interface{}) error {
	config := meta.(*Config)
	userAgent, err := generateUserAgentString(d, config.userAgent)
	if err != nil {
		return err
	}

	billingProject := ""

	project, err := getProject(d, config)
	if err != nil {
		return fmt.Errorf("Error fetching project for Job: %s", err)
	}
	billingProject = project

	url, err := replaceVars(d, config, "{{CloudRunBasePath}}apis/run.googleapis.com/v1/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return err
	}

	var obj map[string]interface{}
	log.Printf("[DEBUG] Deleting Job %q", d.Id())

	// err == nil indicates that the billing_project value was found
	if bp, err := getBillingProject(d, config); err == nil {
		billingProject = bp
	}

	res, err := sendRequestWithTimeout(config, "DELETE", billingProject, url, userAgent, obj, d.Timeout(schema.TimeoutDelete), isCloudRunCreationConflict)
	if err != nil {
		return handleNotFoundError(err, d, "Job")
	}

	log.Printf("[DEBUG] Finished deleting Job %q: %#v", d.Id(), res)
	return nil
}

func resourceCloudRunJobImport(d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
	config := meta.(*Config)
	if err := parseImportId([]string{
		"locations/(?P<location>[^/]+)/namespaces/(?P<project>[^/]+)/jobs/(?P<name>[^/]+)",
		"(?P<location>[^/]+)/(?P<project>[^/]+)/(?P<name>[^/]+)",
		"(?P<location>[^/]+)/(?P<name>[^/]+)",
	}, d, config); err != nil {
		return nil, err
	}

	// Replace import id for the resource id
	id, err := replaceVars(d, config, "locations/{{location}}/namespaces/{{project}}/jobs/{{name}}")
	if err != nil {
		return nil, fmt.Errorf("Error constructing id: %s", err)
	}
	d.SetId(id)

	// Explicitly set virtual fields to default values on import
	if err := d.Set("autogenerate_revision_name", false); err != nil {
		return nil, fmt.Errorf("Error setting autogenerate_revision_name: %s", err)
	}

	return []*schema.ResourceData{d}, nil
}

func flattenCloudRunJobStatus(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["conditions"] =
		flattenCloudRunJobStatusConditions(original["conditions"], d, config)
	transformed["url"] =
		flattenCloudRunJobStatusUrl(original["url"], d, config)
	transformed["observed_generation"] =
		flattenCloudRunJobStatusObservedGeneration(original["observedGeneration"], d, config)
	transformed["execution_count"] =
		flattenCloudRunJobStatusExecutionCount(original["executionCount"], d, config)
	transformed["latest_created_execution"] =
		flattenCloudRunJobStatusLatestCreatedExecution(original["latestCreatedExecution"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobStatusConditions(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return v
	}
	l := v.([]interface{})
	transformed := make([]interface{}, 0, len(l))
	for _, raw := range l {
		original := raw.(map[string]interface{})
		if len(original) < 1 {
			// Do not include empty json objects coming back from the api
			continue
		}
		transformed = append(transformed, map[string]interface{}{
			"message": flattenCloudRunJobStatusConditionsMessage(original["message"], d, config),
			"status":  flattenCloudRunJobStatusConditionsStatus(original["status"], d, config),
			"reason":  flattenCloudRunJobStatusConditionsReason(original["reason"], d, config),
			"type":    flattenCloudRunJobStatusConditionsType(original["type"], d, config),
		})
	}
	return transformed
}
func flattenCloudRunJobStatusConditionsMessage(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusConditionsStatus(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusConditionsReason(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusConditionsType(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusUrl(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusObservedGeneration(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobStatusExecutionCount(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	// Handles the string fixed64 format
	if strVal, ok := v.(string); ok {
		if intVal, err := stringToFixed64(strVal); err == nil {
			return intVal
		}
	}

	// number values are represented as float64
	if floatVal, ok := v.(float64); ok {
		intVal := int(floatVal)
		return intVal
	}

	return v // let terraform core handle it otherwise
}

func flattenCloudRunJobStatusLatestCreatedExecution(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	if v == nil {
		return nil
	}
	original := v.(map[string]interface{})
	if len(original) == 0 {
		return nil
	}
	transformed := make(map[string]interface{})
	transformed["name"] =
		flattenCloudRunJobStatusLatestCreatedExecutionName(original["name"], d, config)
	transformed["creation_timestamp"] =
		flattenCloudRunJobStatusLatestCreatedExecutionCreationTimestamp(original["creationTimestamp"], d, config)
	transformed["completion_timestamp"] =
		flattenCloudRunJobStatusLatestCreatedExecutionCompletionTimestamp(original["completionTimestamp"], d, config)
	return []interface{}{transformed}
}
func flattenCloudRunJobStatusLatestCreatedExecutionName(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusLatestCreatedExecutionCreationTimestamp(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func flattenCloudRunJobStatusLatestCreatedExecutionCompletionTimestamp(v interface{}, d *schema.ResourceData, config *Config) interface{} {
	return v
}

func resourceCloudRunJobEncoder(d *schema.ResourceData, meta interface{}, obj map[string]interface{}) (map[string]interface{}, error) {
	name := d.Get("name").(string)
	if obj["metadata"] == nil {
		obj["metadata"] = make(map[string]interface{})
	}
	metadata := obj["metadata"].(map[string]interface{})
	metadata["name"] = name

	// The only acceptable version/kind right now
	obj["apiVersion"] = "run.googleapis.com/v1"
	obj["kind"] = "Job"
	return obj, nil
}

func resourceCloudRunJobDecoder(d *schema.ResourceData, meta interface{}, res map[string]interface{}) (map[string]interface{}, error) {
	// metadata is not present if the API returns an error
	if obj, ok := res["metadata"]; ok {
		if meta, ok := obj.(map[string]interface{}); ok {
			res["name"] = meta["name"]
		} else {
			return nil, fmt.Errorf("Unable to decode 'metadata' block from API response.")
		}
	}
	return res, nil
}
